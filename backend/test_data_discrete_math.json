[
    {
        "question": "In the context of propositional logic, how can one distinguish a tautology from a contradiction based on the possible truth values of a compound proposition?",
        "ground_truth": "A tautology is a compound proposition that is always true, regardless of the truth values of its individual variables. In contrast, a contradiction is a compound proposition that is always false, regardless of the truth values of its components.",
        "notebooks": [
            "discrete_math"
        ]
    },
    {
        "question": "How is the cardinality of the union of three finite sets $A$, $B$, and $C$ calculated using the Inclusion-Exclusion Principle to account for element overlaps?",
        "ground_truth": "According to the Inclusion-Exclusion Principle, the cardinality is calculated by summing the sizes of the individual sets, subtracting the sizes of their pairwise intersections, and adding the size of the intersection of all three sets: $|A \\cup B \\cup C| = |A| + |B| + |C| - (|A \\cap B| + |A \\cap C| + |B \\cap C|) + |A \\cap B \\cap C|$.",
        "notebooks": [
            "discrete_math"
        ]
    },
    {
        "question": "According to Euler's Theorem, what specific condition regarding vertex degrees serves as both necessary and sufficient for a connected multigraph to contain an Eulerian cycle?",
        "ground_truth": "A connected graph contains an Eulerian cycle if and only if every vertex in the graph has an even degree.",
        "notebooks": [
            "discrete_math"
        ]
    },
    {
        "question": "For a connected planar graph drawn without crossing edges, what is the fundamental algebraic relationship defined by Euler's formula between the number of vertices ($n$), edges ($m$), and faces ($r$)?",
        "ground_truth": "Euler's formula states that for a connected planar graph, the relationship is $n - m + r = 2$ (often written as $v - e + f = 2$).",
        "notebooks": [
            "discrete_math"
        ]
    },
    {
        "question": "What is the operational procedure of Dijkstra's algorithm when determining the shortest paths from a single source node to all other nodes in a graph with non-negative edge weights?",
        "ground_truth": "Dijkstra's algorithm initializes distances to infinity (source to 0), uses a priority queue to repeatedly select the unvisited node with the smallest tentative distance, and relaxes its neighbors by updating their distances if a shorter path is found through the current node.",
        "notebooks": [
            "discrete_math"
        ]
    },
    {
        "question": "In the context of generating a Minimum Spanning Tree (MST), how does the greedy strategy of Prim's algorithm differ structurally from that of Kruskal's algorithm?",
        "ground_truth": "Prim's algorithm builds the MST by growing a single tree from a starting vertex, always adding the cheapest edge connecting the tree to a non-tree vertex. Kruskal's algorithm builds the MST by sorting all edges by weight and adding the cheapest edges globally to form a forest, merging trees while ensuring no cycles are created.",
        "notebooks": [
            "discrete_math"
        ]
    },
    {
        "question": "How are the nodes of a binary tree processed relative to the root and its subtrees in Preorder, Inorder, and Postorder traversal methods?",
        "ground_truth": "In Preorder traversal, the order is Root, then Left Subtree, then Right Subtree. In Inorder traversal, the order is Left Subtree, then Root, then Right Subtree. In Postorder traversal, the order is Left Subtree, then Right Subtree, then Root.",
        "notebooks": [
            "discrete_math"
        ]
    },
    {
        "question": "What characterizes an AVL tree as a self-balancing binary search tree, specifically regarding the allowable height difference between its subtrees?",
        "ground_truth": "An AVL tree is defined by the property that for every node, the height difference (balance factor) between its left and right subtrees is at most 1. If this condition is violated during modification, rotations are performed to rebalance the tree.",
        "notebooks": [
            "discrete_math"
        ]
    },
    {
        "question": "In the theory of binary relations, what specific properties must be present for a relation to be classified as reflexive, symmetric, or transitive?",
        "ground_truth": "A relation $R$ on set $A$ is reflexive if $(a, a) \\in R$ for every $a \\in A$. It is symmetric if $(a, b) \\in R$ implies $(b, a) \\in R$. It is transitive if $(a, b) \\in R$ and $(b, c) \\in R$ imply $(a, c) \\in R$.",
        "notebooks": [
            "discrete_math"
        ]
    },
    {
        "question": "To classify a mathematical function as a bijection (bijective function), which two fundamental mapping conditions must be simultaneously satisfied?",
        "ground_truth": "A function is a bijection if it is both injective (one-to-one), meaning distinct elements map to distinct images, and surjective (onto), meaning every element in the codomain is the image of at least one element in the domain.",
        "notebooks": [
            "discrete_math"
        ]
    },
    {
        "question": "What is the graphical method involved in using Karnaugh maps (K-maps) to simplify Boolean expressions into their minimal Disjunctive Normal Form (DNF)?",
        "ground_truth": "Karnaugh maps simplify Boolean functions by mapping truth values onto a grid where adjacent cells differ by only one bit. Groups of adjacent $1$s (sized in powers of 2) are combined to eliminate variables that change state within the group, yielding the minimal Disjunctive Normal Form (sum of products).",
        "notebooks": [
            "discrete_math"
        ]
    },
    {
        "question": "What is the primary purpose of a Hamming code in data transmission, and how is the number of required redundancy (parity) bits calculated?",
        "ground_truth": "Hamming code is an error-correcting linear block code capable of detecting and correcting single-bit errors. The number of redundancy bits $r$ required for $m$ data bits is calculated using the inequality $2^r \\ge m + r + 1$.",
        "notebooks": [
            "discrete_math"
        ]
    }
]